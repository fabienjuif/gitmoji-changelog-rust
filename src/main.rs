#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate serde_json;
#[macro_use]
extern crate lazy_static;
#[macro_use]
extern crate clap;

use std::fs::{self, File};
use std::io::prelude::*;

use clap::{App, Arg};
use handlebars::Handlebars;
use regex::Regex;

mod changelog;
mod commit;
mod group;
mod version;

use crate::changelog::Changelog;

lazy_static! {
    static ref REG_FROM: Regex = Regex::new("<a name=\"(.*?)\".*").unwrap();
}

const HEADER: &str = "# Changelog";

const FOOTER: &str = "_Generated by [gitmoji-changelog (rust version)](https://github.com/fabienjuif/gitmoji-changelog-rust)_";

const VERSIONS_TEMPLATE: &str = "{{#each changelog.versions as |version|}}
<a name=\"{{version.name}}\" data-comment=\"this line is used by gitmoji-changelog, don't remove it!\"></a>
## Version {{version.name}}
{{#each version.groups as |group|}}
### {{group.name}}
{{#each group.commits as |commit|~}}
 - {{commit.emoji}}  {{commit.summary}}{{#if @root.options.print-authors}} ({{commit.author}}){{/if}}
{{/each~}}
{{/each~}}
{{/each~}}
";

fn main() {
    let matches = App::new("gitmoji-changelog")
        .version(crate_version!())
        .author("Fabien JUIF <fabien.juif@gmail.com>")
        .arg(
            Arg::with_name("output")
                .short("o")
                .long("output")
                .value_name("FILE")
                .help("File to update, if not defined write on stdout")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("print-authors")
                .short("a")
                .long("print-authors")
                .help("Print author for each commit")
                .takes_value(false),
        )
        .arg(
            Arg::with_name("path")
                .value_name("GIT_REPOSITORY_PATH")
                .help("Path to the git repository to parse")
                .required(true),
        )
        .arg(
            Arg::with_name("release")
                .short("r")
                .long("release")
                .help("Set a version to the release (latest tag to HEAD). If not set, the commits after the latest tag will not be printed to the changelog.")
                .takes_value(true)
                .required(false)
        )
        .arg(
            Arg::with_name("delta")
                .long("delta")
                .help("Print delta only (not the whole CHANGELOG).")
                .required(false)

        )
        .get_matches();

    let repository = matches.value_of("path").unwrap();
    eprintln!("Git repository path: {}", repository);

    let format_changelog = |header, from, footer| {
        let mut changelog = Changelog::from(&repository, from);

        match matches.value_of("release") {
            None => changelog.remove_head_version(),
            Some(release_name) => changelog.set_release_name(release_name),
        };

        let mut reg = Handlebars::new();
        reg.set_strict_mode(true);
        let json = json!({
            "changelog": changelog,
            "options": {
                "print-authors": matches.is_present("print-authors"),
            },
        });

        let delta = reg.render_template(VERSIONS_TEMPLATE, &json).unwrap();

        if matches.is_present("delta") {
            return delta;
        }

        format!("{}\n{}\n{}", header, delta, footer)
    };

    let result = match fs::read_to_string(format!("{}/CHANGELOG.md", repository)) {
        Err(_) => format_changelog(HEADER, None, FOOTER),
        Ok(old_changelog) => {
            let mut old_changelog = old_changelog.to_string();
            let last_version_index = old_changelog.find("<a name=").unwrap();
            let rest = old_changelog.split_off(last_version_index);

            let last_version = REG_FROM.captures(&rest).unwrap();
            let last_version = last_version.get(1).map(|c| c.as_str());

            format_changelog(&old_changelog, last_version, &rest)
        }
    };

    match matches.value_of("output") {
        None => println!("{}", result),
        Some(path) => {
            let mut file = File::create(path).unwrap();
            file.write_all(result.as_bytes()).unwrap();
        }
    }
}
